%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Template for USENIX papers.
%
% History:
%
% - TEMPLATE for Usenix papers, specifically to meet requirements of
%   USENIX '05. originally a template for producing IEEE-format
%   articles using LaTeX. written by Matthew Ward, CS Department,
%   Worcester Polytechnic Institute. adapted by David Beazley for his
%   excellent SWIG paper in Proceedings, Tcl 96. turned into a
%   smartass generic template by De Clarke, with thanks to both the
%   above pioneers. Use at your own risk. Complaints to /dev/null.
%   Make it two column with no page numbering, default is 10 point.
%
% - Munged by Fred Douglis <douglis@research.att.com> 10/97 to
%   separate the .sty file from the LaTeX source template, so that
%   people can more easily include the .sty file into an existing
%   document. Also changed to more closely follow the style guidelines
%   as represented by the Word sample file.
%
% - Note that since 2010, USENIX does not require endnotes. If you
%   want foot of page notes, don't include the endnotes package in the
%   usepackage command, below.
% - This version uses the latex2e styles, not the very ancient 2.09
%   stuff.
%
% - Updated July 2018: Text block size changed from 6.5" to 7"
%
% - Updated Dec 2018 for ATC'19:
%
%   * Revised text to pass HotCRP's auto-formatting check, with
%     hotcrp.settings.submission_form.body_font_size=10pt, and
%     hotcrp.settings.submission_form.line_height=12pt
%
%   * Switched from \endnote-s to \footnote-s to match Usenix's policy.
%
%   * \section* => \begin{abstract} ... \end{abstract}
%
%   * Make template self-contained in terms of bibtex entires, to allow
%     this file to be compiled. (And changing refs style to 'plain'.)
%
%   * Make template self-contained in terms of figures, to
%     allow this file to be compiled. 
%
%   * Added packages for hyperref, embedding fonts, and improving
%     appearance.
%   
%   * Removed outdated text.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix-2020-09}

% for urls
\usepackage{hyperref}

% for listings
\usepackage{listings}
\lstset{basicstyle=\ttfamily}

% to be able to draw some self-contained figs
\usepackage{tikz}
\usepackage{amsmath}

% inlined bib file
\usepackage{filecontents}

%-------------------------------------------------------------------------------
\begin{filecontents}{\jobname.bib}
%-------------------------------------------------------------------------------
@misc{gu20ropriscv,
    title={{Return}-{Oriented} {Programming} in {RISC-V}},
    author={Gu, Garrett and Shacham, Hovav},
    year={2020},
    eprint={2007.14995},
    archivePrefix={arXiv},
    primaryClass={cs.CR},
}
@inproceedings{bletsch11jopx86,
    author = {Bletsch, Tyler and Jiang, Xuxian and Freeh, Vince W. and Liang, Zhenkai},
    title = {{Jump}-{Oriented} {Programming}: {A} {New} {Class} of {Code}-{Reuse} {Attack}},
    year = {2011},
    isbn = {9781450305648},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1966913.1966919},
    doi = {10.1145/1966913.1966919},
    abstract = {Return-oriented programming is an effective code-reuse attack in which short code sequences ending in a ret instruction are found within existing binaries and executed in arbitrary order by taking control of the stack. This allows for Turing-complete behavior in the target program without the need for injecting attack code, thus significantly negating current code injection defense efforts (e.g., W⊕X). On the other hand, its inherent characteristics, such as the reliance on the stack and the consecutive execution of return-oriented gadgets, have prompted a variety of defenses to detect or prevent it from happening.In this paper, we introduce a new class of code-reuse attack, called jump-oriented programming. This new attack eliminates the reliance on the stack and ret instructions (including ret-like instructions such as pop+jmp) seen in return-oriented programming without sacrificing expressive power. This attack still builds and chains functional gadgets, each performing certain primitive operations, except these gadgets end in an indirect branch rather than ret. Without the convenience of using ret to unify them, the attack relies on a dispatcher gadget to dispatch and execute the functional gadgets. We have successfully identified the availability of these jump-oriented gadgets in the GNU libc library. Our experience with an example shellcode attack demonstrates the practicality and effectiveness of this technique.},
    booktitle = {Proceedings of the 6th ACM Symposium on Information, Computer and Communications Security},
    pages = {30–40},
    numpages = {11},
    location = {Hong Kong, China},
    series = {ASIACCS '11}
}
@inproceedings{shacham07ropx86,
    author = {Shacham, Hovav},
    title = {{The} {Geometry} of {Innocent} {Flesh} on the {Bone}: {Return}-into-{Libc} without {Function} {Calls} (on the {X86})},
    year = {2007},
    isbn = {9781595937032},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1315245.1315313},
    doi = {10.1145/1315245.1315313},
    abstract = {We present new techniques that allow a return-into-libc attack to be mounted on x86 executables that calls no functions at all. Our attack combines a large number of short instruction sequences to build gadgets that allow arbitrary computation. We show how to discover such instruction sequences by means of static analysis. We make use, in an essential way, of the properties of the x86 instruction set.},
    booktitle = {Proceedings of the 14th ACM Conference on Computer and Communications Security},
    pages = {552–561},
    numpages = {10},
    keywords = {return-into-libc, instruction set, turing completeness},
    location = {Alexandria, Virginia, USA},
    series = {CCS '07}
}
@inproceedings{patterson98risc,
    title={{RISC} {I}: {A} reduced instruction set {VLSI} computer},
    author={Patterson, David A and Sequin, Carlo H},
    booktitle={25 years of the international symposia on Computer architecture (selected papers)},
    pages={216--230},
    year={1998}
}
@inproceedings{checkoway10ropnoret,
    author = {Checkoway, Stephen and Davi, Lucas and Dmitrienko, Alexandra and Sadeghi, Ahmad-Reza and Shacham, Hovav and Winandy, Marcel},
    title = {{Return}-{Oriented} {Programming} without {Returns}},
    year = {2010},
    isbn = {9781450302456},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1866307.1866370},
    doi = {10.1145/1866307.1866370},
    abstract = {We show that on both the x86 and ARM architectures it is possible to mount return-oriented programming attacks without using return instructions. Our attacks instead make use of certain instruction sequences that behave like a return, which occur with sufficient frequency in large libraries on (x86) Linux and (ARM) Android to allow creation of Turing-complete gadget sets.Because they do not make use of return instructions, our new attacks have negative implications for several recently proposed classes of defense against return-oriented programming: those that detect the too-frequent use of returns in the instruction stream; those that detect violations of the last-in, first-out invariant normally maintained for the return-address stack; and those that modify compilers to produce code that avoids the return instruction.},
    booktitle = {Proceedings of the 17th ACM Conference on Computer and Communications Security},
    pages = {559–572},
    numpages = {14},
    keywords = {return-oriented programming, arm, x86},
    location = {Chicago, Illinois, USA},
    series = {CCS '10}
}
@inproceedings{sadeghi15tinyjop,
    author = {Sadeghi, Ali-Akbar and Aminmansour, Farzane and Shahriari, Hamid-Reza},
    year = {2015},
    month = {09},
    pages = {52-57},
    title = {{Tiny} jump-oriented programming attack ({A} class of code reuse attacks)},
    doi = {10.1109/ISCISC.2015.7387898}
}
@inbook{jaloyan20ropriscv,
    author = {Jaloyan, Georges-Axel and Markantonakis, Konstantinos and Akram, Raja Naeem and Robin, David and Mayes, Keith and Naccache, David},
    title = {{Return}-{Oriented} {Programming} on {RISC-V}},
    year = {2020},
    isbn = {9781450367509},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3320269.3384738},
    abstract = {This paper provides the first analysis on the feasibility of Return-Oriented programming (ROP) on RISC-V, a new instruction set architecture targeting embedded systems. We show the existence of a new class of gadgets, using several Linear Code Sequences And Jumps (LCSAJ), undetected by current Galileo-based ROP gadget searching tools. We argue that this class of gadgets is rich enough on RISC-V to mount complex ROP attacks, bypassing traditional mitigation like DEP, ASLR, stack canaries, G-Free and some compiler-based backward-edge CFI, by jumping over any guard inserted by a compiler to protect indirect jump instructions. We provide examples of such gadgets, as well as a proof-of-concept ROP chain, using C code injection to leverage a privilege escalation attack on two standard Linux operating systems. Additionally, we discuss some of the required mitigations to prevent such attacks and provide a new ROP gadget finder algorithm that handles this new class of gadgets.},
    booktitle = {Proceedings of the 15th ACM Asia Conference on Computer and Communications Security},
    pages = {471–480},
    numpages = {10}
}
@manual{riscvmanual,
    author = {Waterman, Andrew and Asanovic, Krste},
    title = {{The} {RISC-V} {Instruction} {Set} {Manual}, {Volume} {I}: {User}-{Level} {ISA}, {Document} {Version} {20191213}},
    note = {\url{https://github.com/riscv/riscv-isa-manual}}
}
@inproceedings{fixer,
    author={A. {De} and A. {Basu} and S. {Ghosh} and T. {Jaeger}},
    booktitle={2019 Design, Automation   Test in Europe Conference   Exhibition (DATE)}, 
    title={FIXER: Flow Integrity Extensions for Embedded RISC-V}, 
    year={2019},
    volume={},
    number={},
    pages={348-353},
    doi={10.23919/DATE.2019.8714980}
}
@misc{zipper,
    title={Zipper Stack: Shadow Stacks Without Shadow}, 
    author={Jinfeng Li and Liwei Chen and Qizhen Xu and Linan Tian and Gang Shi and Kai Chen and Dan Meng},
    year={2020},
    eprint={1902.00888},
    archivePrefix={arXiv},
    primaryClass={cs.CR}
}
@inproceedings{bosman14sigrop,
    author={E. {Bosman} and H. {Bos}},
    booktitle={2014 IEEE Symposium on Security and Privacy}, 
    title={Framing Signals - A Return to Portable Shellcode}, 
    year={2014},
    volume={},
    number={},
    pages={243-258},
    doi={10.1109/SP.2014.23}
}
@inproceedings{payer13sop,
    author = {Payer, Mathias and Gross, Thomas R.},
    title = {String Oriented Programming: When ASLR is Not Enough},
    year = {2013},
    isbn = {9781450318570},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2430553.2430555},
    doi = {10.1145/2430553.2430555},
    abstract = {Control-data attacks are a well known attack vector; these attacks either inject new code into running applications or reuse existing code in an unintended way to execute their malicious payload.Current software systems are protected against control-data attacks using numerous mechanisms like Data Execution Prevention (DEP), stack canaries, and Address Space Layout Randomization (ASLR). ASLR turns deterministic attacks into probabilistic attacks and reduces the probability of a successful attack. Unfortunately, the current ASLR implementation for Linux leaves some memory regions non-randomized. These static memory regions can be used to exploit applications that have ASLR, DEP, and stack canaries enabled.Format string exploits are an often overlooked attack vector that enables attacker-controlled memory writes in an application. A format string bug exists if a user-supplied string is passed as a first argument to any printf function. The only prerequisite for a successful format string exploit is that the attacker must be able to control that format string.This paper presents String Oriented Programming (SOP), an approach that exploits static memory regions in ASLR enabled applications. SOP uses a format string bug to exploit applications that are protected by a combination of weak ASLR, DEP, and stack canaries. Similar to return oriented programming or jump oriented programming, SOP does not rely on existing code but concatenates gadgets in the application using static program analysis.},
    booktitle = {Proceedings of the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop},
    articleno = {2},
    numpages = {9},
    location = {Rome, Italy},
    series = {PPREW '13}
}
@InProceedings{shacham15lejit,
  author =       {Wilson Lian and Hovav Shacham and Stefan Savage},
  title =        {Too {LeJIT} to Quit: Extending {JIT} Spraying to
                  {ARM}},
  booktitle =    {Proceedings of NDSS 2015},
  year =         2015,
  editor =       {Engin Kirda},
  month =        feb,
  organization = {Internet Society}
}


\end{filecontents}

%-------------------------------------------------------------------------------
\begin{document}
%-------------------------------------------------------------------------------

%don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Exploring Jump-Oriented-Programming in RISC-V}

%for single author (just remove % characters)
\author{
{\rm Daniel Starikov}\\
Univeristy of Washington
\and
{\rm Keanu Vestil}\\
University of Washington
% copy the following lines to add more authors
% \and
% {\rm Name}\\
%Name Institution
} % end author

\maketitle

%-------------------------------------------------------------------------------
\begin{abstract}
%-------------------------------------------------------------------------------
This paper explores the viability of jump-oriented-programming (JOP) on RISC-V,
a new open-source ISA that is gaining popularity in embedded systems. We add to
the code reuse attack repertoire by extending variations of return-oriented-%
programming from their initial architectures to RISC-V. We analyze \verb|libc|
for real JOP gadgets that can be used for these attacks, and find versatile
gadgets that allow us to trivially issue arbitrary library calls such as
printing strings using \verb|putchar| or launching a shell using \verb|execve|.
\end{abstract}


%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

RISC-V is a free and open instruction set architecture (ISA) introduced by UC
Berkeley in 2010. Although it was initially designed for research and education
purposes, it is being increasingly used in commercial settings. RISC-V is a
based on the reduced instruction set computer (RISC) paradigm. This aims to
improve a machine's throughput by simplifying instructions and addressing modes,
thus reducing the cycles needed per instruction and reducing the time per cycle~\cite{patterson98risc}.

Code injection attacks involve an adversary supplying arbitrary code through an
innocuous input in a program, and later hijacking control flow to this code.
While the can be prevented by measures such as W$\oplus$X, code reuse attacks
such as return-oriented-programming can be just as effective.

Return-oriented-programming, or ROP, involves the reuse of short instruction
sequences that end with a return instruction~\cite{shacham07ropx86}. These short sequences are referred
to as gadgets. The capability of a gadget can vary, but its functionality by
itself is usually quite limited. However, when they are chained together, it has
been shown that an attacker can execute arbitrary operation. The attacker
supplies addresses to these gadgets, and other values that they may acquire from
memory. These gadgets are then execute in order as though they are instructions
for a strange computer built on the misuse of registers and code fragments.

There have been many variations of ROP presented since its initial discovery.
These include ROP without returns~\cite{checkoway10ropnoret},
sigreturn-oriented-programming~\cite{bosman14sigrop},
jump-oriented programming~\cite{bletsch11jopx86}, and string-oriented-programming~\cite{payer13sop}. These variations
seek to bypass defenses that focus on certain aspects of one ore more of their
peers. While ROP was originally proposed for the x86 architecture, it has been
demonstrated on many other CISC and even RISC architectures. The variations of
ROP have also been demonstrated on alternate architectures.

While there has been some recent work demonstrating ROP on RISC-V~%
~\cite{gu20ropriscv,jaloyan20ropriscv}, there has not been an explicit
exploration into jump-oriented programming on these systems. In this work, we
explore jump-oriented programming on RISC-V and show that it can be used to make
arbitrary calls to libc. Furthermore, we present a new recipe of gadgets that
uses a dispatcher gadget followed by a versatile initializer gadget, and
demonstrate how they can be chained together.

The remainder of this paper is organized as follows: Section 2 walks through our
approach for re-implementing ROP in RISC-V and implementing a closely related
variant. Next, Section 3 explains how we implemented jump-oriented programming,
its limitations, and how we searched for our gadgets. Section 4 discusses our
results in general, and what we are able to do with them. Section 5 presents
related work that is tangential to ours. Finally, Section 6 concludes this paper
and posits ideas for future work.

%-------------------------------------------------------------------------------
\section{Implementing Variations of ROP}
%-------------------------------------------------------------------------------

We thought it would be beneficial to recreate previously demonstrated ROP attacks
so that we could familiarize ourselves with the process. We began by testing the
RISC-V ROP attack described in Gu and Shacham~\cite{gu20ropriscv}. We cloned
their publicly available GitHub repository to our machine and successfully
replicated their ROP attack on our RISC-V VM. To replicate their attack on our VM, we
found the exact version of \verb|libc.so| that the authors used and cross-referenced
it with the addresses from their compiler to find their exact gadgets. We then
implemented these gadgets in an assembly file and modified their compiler to use
the addresses of our gadgets. With this in place we were able to successfully execute
brainfuck~\cite{gu20ropriscv} programs through ROP on our VM's. Next we sought to port a variant of
ROP, which does not use returns~\cite{checkoway10ropnoret}, from x86 to RISC-V.

At first, we reused the gadgets that we implemented in the aforementioned plain ROP
attack. Instead of loading the return address into \verb|ra|, we modified the
gadgets to load it into \verb|a6|. The \verb|ret| and \verb|jalr ra|
instructions at the end of each gadget were replaced with \verb|c.jalr a6|.
Since \verb|a6| was otherwise unused in our gadgets, this functionality is
effectively the same as normal behavior with the exception that the \verb|ret|
and \verb|jalr ra| mnemonics are never used. This was a successful proof of
concept, but it was not realistic because it relied on gadget modification that
we manufactured.

Checkoway et al. described a ``trampoline'' gadget that could be reused to
achieve this \verb|ret|-like behavior. We were able to successfully implement
a simplified version of this attack using a real \verb|ret| gadget which incremented
the stack pointer and performed a ret, allowing us to reuse the JOP versions of ROP gadgets that
relied on loading from the stack. We modified our gadgets ending with \verb|c.jalr a6|
to no longer modify the stack pointer. We then rewrote the brainfuck to ROP compiler
from \cite{gu20ropriscv} to use our updated JOP gadgets and chained them together
using the new \verb|ret| gadget. Finally, we demonstrated that this could extend to a
full ROP-without-returns attack by replacing the real \verb|ret| gadget with one
that we wrote ourselves which increments the stack pointer and ends with an indirect jump.
This attack is also not realistic as it relies on the modified gadgets that use the stack
and requires an unrealistic gadget that increments the stack before performing an indirect jump.

%-------------------------------------------------------------------------------
\section{Implementing JOP}
%-------------------------------------------------------------------------------

In this section we describe our methodology for crafting a jump-oriented
programming attack. In addition, we discuss its capabilities, limitations, and
possible real-world applications. Our approach is inspired by the previous work
on this topic by Bletsch et al.~\cite{bletsch11jopx86}. Their research was done
on x86, so part of our work was to translate their results to work in RISC-V. In
their findings, they describe a \textit{dispatcher} gadget and an
\textit{initializer} gadget. A dispatcher gadget increments a register that is
used as a pseudo-program counter and then jumps to the address stored at that
next address. An initializer gadget loads many (or perhaps all) registers that
the proceeding gadgets rely on. In x86, the \verb|popa| instruction loads every
general purpose register from the stack. There is no such luxury in RISC-V, but
we found a gadget that achieves a similar effect.

There is a powerful initializer gadget in the \verb|setcontext| function from
\verb|libc|. It loads almost all%
% TODO: \verb| | the registers in this foonote, somehow
\footnote{gp, tp, t0, t2, t3, t4, t5, and t6 are the only registers that are not set by this
initializer gadget.}
general purpose registers from memory, based on the address in the \verb|t0|
register, and then it jumps to the address that it just loaded into \verb|t1|.
The disassembly of this initializer gadget is shown in Figure~%
\ref{initializer gadget} The ability to load so many register from memory and
to subsequently jump to an address that we can arbitrarily define makes this
gadget quite versatile. However, before we can utilize it, we must set \verb|t0|
to point to our dispatch table (which contains all the values that we wish to
load) in memory.

We found dispatcher gadgets that set \verb|t0| from one of the registers that we
can control with our initializer gadget, and then jump to a different register
that we control. Figure~\ref{dispatcher gadget} shows an example of these
dispatcher gadgets. We use one of these dispatcher gadgets as a prologue to the
initializer gadget, as it allows us to prepare the dispatch table for the
initializer gadget to load values from. Furthermore, we can endlessly chain
these gadgets together by setting the source register of the next dispatcher
gadget using the initializer gadget that precedes it. We (facetiously) refer to
this combo as our \textit{dispatchilizer} gadget.

\begin{figure}
    \caption{Initializer gadget}
    \label{initializer gadget}
    \begin{lstlisting}
    ld       t1,176(t0)
    ld       ra,184(t0)
    ld       sp,192(t0)
    ld	     s0,240(t0)
    ld	     s1,248(t0)
    ld	     a0,256(t0)
    ld	     a1,264(t0)
    ld	     a2,272(t0)
    ld	     a3,280(t0)
    ld	     a4,288(t0)
    ld	     a5,296(t0)
    ld	     a6,304(t0)
    ld	     a7,312(t0)
    ld	     s2,320(t0)
    ld	     s3,328(t0)
    ld	     s4,336(t0)
    ld	     s5,344(t0)
    ld	     s6,352(t0)
    ld	     s7,360(t0)
    ld	     s8,368(t0)
    ld	     s9,376(t0)
    ld	     s10,384(t0)
    ld	     s11,392(t0)
    jr	     t1
    \end{lstlisting}
\end{figure}

\begin{figure}
    \caption{Dispatcher gadget}
    \label{dispatcher gadget}
    \begin{lstlisting}
    mv      t0,s3
    jr      a3
    \end{lstlisting}
\end{figure}

% TODO: flesh these sections out
\subsection{Proof of Concept}
%-------------------------------------------------------------------------------

As our initial attempt, we implemented a simplified JOP attack using only
gadgets found from \verb|libc.so.6|. The attack is initialized by a gadget from
\verb|longjmp| which loads a set of registers from the stack and returns to the
first JOP gadget in our chain. We chained together multiple JOP gadgets to set
up the necessary registers to open a shell with the \verb|execve| function.

Next, we implemented a version of the JOP dispatch-table attack described in
\cite{bletsch11jopx86}. We made use of the dispatchilizer gadget that we
previously described. After the first use of the dispatchilizer, we can jump to
a short JOP chain that ends with a jump back to the dispatchilizer, allowing us
to execute the next JOP chain. This allows us to trivially chain together
multiple function calls by loading the the argument registers (\verb|a0-7|) in
the initializer portion, preparing the next jump to the dispatchilizer, and
jumping to the function which then returns to dispatchilizer. 

We demonstrated this capability by implementing a dispatch table compiler in
Python which is able to chain calls to arbitrary functions and other gadgets.
Figure~\ref{dispatch table} shows an example dispatch table that calls multiple
short JOP chains and various \verb|libc| functions. Each buffer contains the
registers for the initializer gadget to load. The first buffer will load
the dispatcher gadgets address into \verb|t1|, causing execution to jump to
the dispatcher. The dispatcher then moves \verb|s3|, which contains the address
of the next buf, into \verb|t1| before jumping to \verb|a3| which contains
the address of \verb|putchar|. Finally \verb|putchar| will print the character
in \verb|a0| before returning to the address in \verb|ra|, which contains the
initializer gadgets address. The initializer will then load the register values
to execute \verb|printf| in the same manner. buf3 executes scanf and clobbers
\verb|t0| and \verb|a3|. Thus a short JOP chain after the function call is
required: first going to a gadget to setup the dispatcher jump address,
then the dispatcher to setup the next dispatch table buffer, and finally the
initializer gadget. buf4 demonstrates a function call using a dereferenced
pointer as an argument. There is a short JOP chain prior to calling
printf which loads memory from an address in register \verb|s0| into \verb|a1|,
sets the argument in \verb|a0| clobbered by the previous gadget, and finally
calls printf with the stack pointer pointing to attacker controlled memory
that will be restored to registers when printf returns. These registers
are set in the printf\_stack buffer and continue the JOP chain to the next
initializer gadget. This gadget sets up the argument registers as pointers
to an array of strings containing an executable and arguments to pass to
execve. We demonstrate how this can be used to execute arbitrary executables
or even shell scripts.We show how this can be used to pass in a script that
opens a reverse-shell to the attacker over the network.

\begin{figure}
    \caption{Dispatch table chaining function calls}
    \label{dispatch table}
    \begin{center}
    \scriptsize
    \begin{tabular}{|c|l|l|}
    \hline
    buf1        &\verb|t1| = \&dispatcher              &\verb|s3| = \&buf2\\
    (putchar)   &\verb|a3| = \&\verb|putchar|          &\verb|a0| = ‘z’\\
                &\verb|ra| = \&initializer             &\\
    \hline
    buf2        &\verb|t1| = \&dispatcher              &\verb|s3| = \&buf3\\
    (printf)    &\verb|a3| = \&\verb|printf|           &\verb|a0| = \&"Enter a number: "\\
                &\verb|ra| = \&initializer             &\\
    \hline
                &\verb|t1| = \&\verb|scanf|            &\verb|s3| = \&buf4 \\
    buf3        &\verb|ra| = \&mv\_s2\_to\_a3\_j\_s1   &\verb|a0| = \&"\%d"\\
    (scanf)     &\verb|s1| = \&dispatcher              &\verb|a1| = \&integer\_ptr\\
                &\verb|s2| = \&initializer             &\\
    \hline
    buf4        &\verb|t1| = \&ld\_a1\_from\_s0\_j\_a5 &\verb|s0| = \&integer\_ptr\\
    (printf)    &\verb|a5| = \&mv\_s6\_to\_a0\_j\_s5   &\verb|s6| = \&"you entered: \%d$\backslash$n"\\
                &\verb|s5| = \&\verb|printf|           &\verb|sp| = \&printf\_stack\_buf\\
    \hline
                &\verb|ra| = \&mv\_s2\_to\_a3\_j\_s1   &\\
    printf stack&\verb|s1| = \&dispatcher              &s3 = \&buf5\\
                &\verb|s2| = \&initializer             &\\
    \hline
                &char* strings[] =                     &str1 = "/bin/bash"\\
    strings buf &\{\&str1, \&str2, \&str3, 0\}         &str2 = "-c"\\
                &                                      &str3 = "<bash script>"\\
    \hline
    buf5        &\verb|t1| = \&dispatcher              &\verb|s3| = \&buf6\\
    (execve)    &\verb|a3| = \&\verb|execve|           &\verb|a0| = \&str1\\
                &\verb|ra| = \&initializer             &\verb|a1| = \&s\\
    \hline
    \end{tabular}
    \end{center}
\end{figure}

% TODO: real-world vulnerable program (setjmp)

\subsection{Limitations}
%-------------------------------------------------------------------------------

In order to start this attack we need the ability to set \verb|t0| to our first
dispatch table. Next, we need a way to store the to-be-loaded values in memory.
Finally, as with any attack that targets the control flow of a program, we need
to redirect execution to our dispatchilizer gadget, or at least the initializer
portion of it.

In the current state of our attack, we need the virtual addresses of the
gadgets we use ahead of time. While this means our attack could be thwarted by
ASLR, there are a number of ways to get around this that we consider out of
scope for our research.

\subsection{C Extension and Misinterpretation}
%-------------------------------------------------------------------------------

The standard extensions of RISC-V---IMAFD, collectively identified as ``G''---%
utilize exclusively 32-bit instructions. As such, instructions are required to
be 4-byte aligned. If a branch or a jump leads to an address that is not 4-byte
aligned, then an instruction address misaligned exception is raised~%
\cite{riscvmanual}. The C extension of RISC-V introduces 16-bit alternatives for
common instructions. Some examples are when one of the registers is \verb|zero|,
\verb|ra|, or \verb|sp|, and when the first source register and the destination
register are identical. This extension reduces aforementioned 4-byte instruction
alignment requirement to 2 bytes, in order to allow for better code density.

This relaxed requirement also allows the ability to misinterpret instructions.
One example is that the latter 16 bites of a 32-bit instruction, in conjunction
with the first 16 bits of the following instruction, could be interpreted as
a valid, unintended 32-bit instruction. Another way this can occur is if the
latter 16 bits of a 32-bit instruction encode a valid 16-bit instruction from
the C extension.

Due to the limited possible sizes of RISC-V instructions, this misinterpretation
is nowhere near as effective as that described in Shacham's original ROP
paper~\cite{shacham07ropx86}. However, Jaloyan et al. demonstrate that overlapping
instruction caused by such misinterpretation can still be utilized in an
attack\cite{jaloyan20ropriscv}. We also make use of this strategy to look for
additional jump-based gadget to add to our repertoire.

In order to search for these gadgets, we re-implemented the Galileo algorithm
described in \cite{shacham07ropx86}. However, since our RISC-V instructions can
only have sizes of 16 or 32 bits, the backtracking aspect is much simpler. Our
implementation is as follows: We scan forward until we find a jump instruction.
Then we work backwards, two bytes at a time, and try to disassemble instructions
starting from the new address. Sometimes this can re-misinterpret the initial
jump instruction that we started from, into a different instruction and the
sequence becomes unusable. Other times we may encounter bytes that do not encode
a valid instruction, and this also renders our potential gadget unusable. We
hypothesize that, due to the sparsity of instruction on RISC-V, this approach
can only find a limited number of usable instruction, let alone usable ones.

After some initial attempts with this technique, we were able to find a new
gadget that could increase \verb|t0| based on a register that we control,
\verb|s7|. Figure~\ref{misinterpreted gadget} shows the gadget that we found,
and Figure~\ref{actual code sequence} shows what the actual code (which starts
2 bytes before) is. This gadget ends with \verb|ret|, which is equivalent to
\verb|jalr ra|. Since we can control \verb|ra| with our initializer gadget, we
can still make use of it. We recognize that this is not technically a JOP
gadget, but it is possible that there are other more complicated gadgets that
accomplish this functionality with the use of \verb|ret|. What we have shown is
that misinterpreted gadgets can give us functionality that we otherwise did not
previously have.

\begin{figure}
    \caption{Misinterpreted gadget}
    \label{misinterpreted gadget}
    \begin{lstlisting}
    add     t0,t0,s7
    li      a0,2
    ret
    \end{lstlisting}
\end{figure}
\begin{figure}
    \caption{Actual code sequence}
    \label{actual code sequence}
    \begin{lstlisting}
    jal     ra,0xb331c
    li      a0,2
    ret
    \end{lstlisting}
\end{figure}

\subsection{Following Relative Jumps}

Our initial attempt to search for jump gadgets using our modified Galileo
algorithm presented us with many gadgets that end in relative jumps. At first
glance, these gadgets are unusable because they redirect control flow to a
destination that we do not control. However, it is possible that some of these
gadgets jump to a short instruction sequence which ends with an indirect jump.
If the indirect jump is determined by a register that we control, then these
gadgets would possible become of interest to us.

\textit{This space is left for further results regarding this idea.}

% TODO: we don't have any gadgets for storing data.
% TODO: we don't have any gadgets for storing data.

%-------------------------------------------------------------------------------
\section{Discussion}
%-------------------------------------------------------------------------------

We successully demonstrated the effectiveness of ROP and JOP attacks from
~\cite{checkoway10ropnoret,bletsch11jopx86,sadeghi15tinyjop} on the RISC-V
architecture. RISC-V is a RISC-based ISA, like ARM, and the same limitations
with translating x86 attacks to ARM apply to RISC-V as well. Implementing
complex chains of JOP gadgets in RISC-V is made difficult for the same reasons
as described in \cite{bletsch11jopx86}: there is a layer of interdependency
between JOP gadgets as certain registers need to be maintained to serve as the
state of the dispatcher between short chains. We work around this limitation
by using a initializer gadget which relies on a rarely-used register \verb|t0|
that always points to our dispatch table to load any values we want into nearly
any register. This allows us to construct short length JOP chains before
jumping back to the initializer gadget in order to setup the next JOP chain.
This doesn't solve the problem of interdependency however as we now require
that each short JOP chain moves \verb|t0| forward in the dispatch table before
jumping back to the initializer gadget. The benefit of this initializer
gadget is that it makes calling arbitrary functions a simple task as it provides
full control over function-argument registers in addition to the stack-pointer and
return address. This allows us to implement powerful attacks by simply calling
multiple functions rather than requiring a set of turing-complete chainable JOP gadgets.

AArch32, 32-bit ARM, supports variable length instructions: execution mode can be changed
to either 32-bit ARM mode or 16-bit Thumb mode, and Thumb2 mode allows for executing
both on a 16-bit alignment. This enables the processor to execute misaligned
instructions and has been used in other code-reuse attacks such as JIT spraying~\cite{shacham15lejit}.
AArch64, 64-bit ARM, on the other hand only supports single-sized instructions,
limiting the set of gadgets available for ROP and JOP attacks in other literature. 
The RV64GC variant of RISC-V introduces a set of compressed instructions that
allows for variable length instructions - this is less powerful than the
variable length instructions of x86 but still enabled us to find additional useful
gadgets which made our attack more powerful. In our initial JOP attack, the pointer
to the next dispatch buffer needs to be loaded into \verb|t0| before calling the
initializer gadget. This incurs a limitation of needing to know the exact
address at which the dispatch-table will be stored in memory when crafting the exploit.
This is an unrealistic limitation given ASLR. We found very few usuable JOP gadgets in
\verb|libc| that gave us to control over \verb|t0|. Searching for unintended
compressed instructions revealed an additional set of short JOP gadgets, including ones
that modified \verb|t0|. We used one such unintended gadget to increment \verb|t0|
before jumping to another register. This allowed us to construct a dispatch table that
did not need to contain pointers to the next dispatch buffer in the dispatch table,
making our attack much more feasible against ASLR.

%-------------------------------------------------------------------------------
\section{Related Work}
%-------------------------------------------------------------------------------
There have been multiple papers investigating control-flow integrity (CFI) 
extensions to the RISC-V ISA ~\cite{zipper,fixer}. Zipper \cite{zipper}
implements a shadow stack to defend against ROP attacks by detecting when return
addresses are overwritten by a buffer-overflow. This does not protect against
purely JOP attacks which rely on jump addresses being overwritten. However, they
do add additional protections for attacks exploiting Setjmp/Longjmp which would
prevent our example attack against a program with a vulnerable call to 
\verb|longjmp|.

Fixer \cite{fixer} implements a tagged RISC-V architecture for CFI and also 
uses a shadow stack to protect against overwriting return addresses. They 
implement additional protections against forward-edge attacks such as indirect
jumps by analyzing code both statically and at runtime to construct a control
flow graph that acts as a policy matrix to validate jumps and function calls.
This type of system should be effective at defending against the JOP attacks
that we have demonstrated. One possible workaround would be to only use
misinterpreted compressed instructions for jumps as these wouldn't be in the
policy matrix. Being limited to only compressed instructions would greatly limit
the effectiveness of a JOP attack. This could furthermore be defended against
in by simply disallowing any jumps that to do not have any entries in the policy
matrix.
%-------------------------------------------------------------------------------
\section{Conclusion and Future Work}
%-------------------------------------------------------------------------------
We have shown that on RISC-V it is possible to run a jump-oriented programming
attack as well as a return-oriented-programming attack without any return
instructions. These attacks can be mounted in a similar manner as seen in
research on other architectures such as x86 and ARM on RISC-V. The same vulnerable
code snippets from those attacks on other ISA's can likewise be exploited on RISC-V
by following the same attack paradigms as demonstrated on ARM. Exploiting bufffer
overflows with jump-oriented-programming is a difficult task due to the complexities
of needing to manage and preserve registers across chains of gadgets with register
interdependencies. We worked around this by finding and utilizing a very powerful
initializer gadget, allowing us to easily chain multiple function calls. Unlike ARM,
RISC-V has support for variable length instructions in the form of the Compressed
RISC-V extension. We showed how this can be used to find additional useful gadgets
that are otherwise unavailable, extending the toolset of gadgets available to
attackers developing ROP or JOP attacks. JOP attacks are resilient to many of
the defenses against ROP, but can most likely be prevented by code flow integrity
checks in the processor.

Future work in this space would be to automate the process of finding gadgets and
crafting attacks through the use of automated SMT solvers. Additionally, more
research can be done into how Code Flow Integrity can be implemented to defend against
the misuse of indirect jumps.


%-------------------------------------------------------------------------------
% \section*{Acknowledgments}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
\section*{Availability}
%-------------------------------------------------------------------------------
Our attacks were written for riscv64 Debian GLIBC 2.31-4\\
The implementations of these attacks can be found in the various branches of our
repository on Github:\\
\url{https://github.com/dstarikov/riscv-jop}


%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{\jobname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
